# Terret Assignment – Star Wars Planets Dashboard

## Setup instructions

Make sure you have node 22+ installed  
https://nodejs.org

### Install dependencies

```bash
npm install
```

### Run

```bash
npm run dev
```

### Code format

```bash
npm run format
```

### Lint

```bash
npm run lint
```

## Requirements

- Display a table of Star Wars planets, with the columns asked: ✅
- Implement Sort and filtering: ✅
- Show the detail in a modal with data and charts: ✅
- Make dialog sharable with a link: ✅ eg. http://localhost:5173/?dialog=%7B%22id%22%3A%22PlanetDetailDialog%22%2C%22props%22%3A%7B%22planetUrl%22%3A%22https%3A%2F%2Fswapi.dev%2Fapi%2Fplanets%2F11%2F%22%7D%7D
- Local Persistence for favorites in local storage: ✅
- Unit tests for most important parts: ✅

## AI Usage

I used ChatGPT integrated with VSCode to handle easier the context of the opened tabs.

- Asked for example chatgpt to create the httpClient I using based on axios but simpler, just to handle the fetch and error handling.
- Create the doc strings for function that I have wrote
- Create some of the unit tests. Most of the time it mess with the types and it does not cover important logic, had to adapt it.
- Create some utility function like the one comparePlanets and reduceResidentsData but good bad BigO, had to refactor it.
- Asked to review this README file mostly to catch typos.
- I left some comments with // Generated by AI, for easier check what was ai generated.

AI was used as a coding assistant, but final logic and types were reviewed and refactored manually.

## Architecture decisions and reasoning

1 - Choose to use TypeScript + ESLint + Prettier for good code quality, making maintainability easier. Everything is typed.  
2 - Separated the strings in `/locales` to make internationalization easier.  
3 - Created a singleton for dialogs (`/dialogs`), here we have the controller to handle the list of what is open and has to be close using `useSyncExternalStore` native hook to make it work fine with React. It has a provider attached to the App to render the dialogs, and it can be opened from anywhere, even outside a React component. The `open` function is fully typed, ensuring you know which dialogs are registered and what props they require. The dialog props are serialized in the URL using `JSON.stringify` and encoded for safe parsing on reload.  
4 - Created a couple of reusable UI components and utilities in order to reuse code  
5 - Declared a global style with css variants to help keep standardization and a design system  
6 - Services holds the layer of the third party api and data manipulation needed to render as customHooks  
7 - Used React Charts to meet the requirements. I applied a lazy loading since this lib is big and this app is a Client Side SPA. This way we can separate better the bundles. In a big application that can make a difference

## Faced challenges

1- Vite updated a few months ago, found some issues to make it work properly with Vitest, DOC did not help, AI also did not help, it should only deprecated code. Tried even to use Gemini that powered by google search could bring something newer, but I could search for the bugs and make it work. (Vite 5.x + Vitest 1.x integration)  
2- About the requirements, it was actually straight forward, the only thing that took my attention was about the pagination and sorting. The api provides searching that we could use for filtering but not sorting. The requirement was clear that we needed to sort all, not only the page. This way I had to based on teh total results and limit of 10 per page, do a function to do the first call, then call all other pages using a `Promise.all` (more performant, as it fetches all pages simultaneously) merge first call and the rest to get all planets and apply a client side pagination and sort.

## What could be improve with more time

About architecture  
1 - Probably setup tailwind for styles  
2 - Add Storybook to document reusable components  
3 - Use React Query to manage api data and caching for it  
4 - If internationalization is needed, use i18next, other libs or even create a controller for it.

About APP functionality  
1- Sort asc and dsc  
2- If we could control the backend delegate the pagination for it. Since sorting was not available in the API, I had to fetch everything and sort in the client side. Search was available, we could use the server pagination but as we had to get all for sort, I just paginated on the client.  
3- Refine the UI and Layouts  
4 - Add E2E tests with Playwright or TestCafe to cover user flows.
